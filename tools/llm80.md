# Z80 代数アセンブリ言語フィルタ llm80
- [Z80 代数アセンブリ言語フィルタ llm80](#z80-代数アセンブリ言語フィルタ-llm80)
  - [特徴](#特徴)
  - [ソース ファイルとコマンド ライン](#ソース-ファイルとコマンド-ライン)
  - [ソースの書き方](#ソースの書き方)
    - [C の関数](#c-の関数)
    - [マクロ定義](#マクロ定義)

## 特徴
- 可読性が高い代数ニーモニック (以下 **LLM**) です
- c と関数単位で混在できます
- VS Code の Microsoft C 文法チェッカをパスします
- if や while 構文があるので, ラベルが少なくなります

## ソース ファイルとコマンド ライン
- LLM のソースは, C ソースのインライン アセンブリ言語として扱います
- 拡張子は **.llm.c** を推奨します
- これを llm80 でコンバートして, インラインアセンブラ込みの c ソースとして出力します
```
php llm80.php foo.llm.c foo.c
```
- ヘッダには LLM ソースは書きません. 従来のインライン アセンブラを使用してください
- SDCC の旧インライン アセンブラ形式 (__asm ～ __endasm;) で出力します<br>
  そのうち一般的な書式 (asm("～"))にするかも

## ソースの書き方
- 関数単位で C と混在できます
- ヘッダにはコードは書きません
- 最初に llm80.h を include します
```
#include "llm80.h"
```
- そのあとは2通りの書き方があります

### C の関数
- 関数単位で書きます. 関数内で C とインライン アセンブラを混在するような書き方はできません
- 関数定義の前後に, 必要に応じて「引数未使用警告」「戻値未設定警告」を抑止する pragma を入れておきます
- 関数定義に「__llm」修飾子を追加します
- 関数内最初に「LLM_DEF_VARS」を記述します
```
pragma save
#pragma disable_warning 85          // 引数未使用警告抑止
#pragma disable_warning 59          // 戻値未設定警告抑止
char add1(const char x) __llm __z88dk_fastcall
{
  LLM_DEF_VARS;                     // L = 引数 (sdcc 昔の呼び出し規約)
  L++;                              // L = 戻値 (sdcc 昔の呼び出し規約)
  // ret 命令は SDCC が自動で追加します
}
#pragma restore
```

- naked 関数の場合は最後に必ず「LLM_NO_RETURN」か「LLM_FALL_THROUGH」を記述しないとエラーになります (naked 関数であることを強調するため)
```
void foo(void) __llm __naked
{
  LLM_DEF_VARS;
  /* あなたのコード */
  jp(bar);
  LLM_NO_RETURN;
}
```

### マクロ定義
- 関数のように書きます
- 関数名は必ず UPPER_SNAKE_CASE でなければなりません (でないとエラー)
- 関数定義に「__llm_macro」修飾子を追加します
- 関数引数がある場合は, すべて int 型にしてください (パーサの手抜きのため)
- 最初に「LLM_DEF_VARS」を記述します
- 最後に必ず「LLM_ENDM」を記述しないとエラーになります (マクロの末端であることを強調するため)
```
char FOO(int x) __llm_macro
{
  LLM_DEF_VARS;
  x++;
  LLM_ENDM;
}
